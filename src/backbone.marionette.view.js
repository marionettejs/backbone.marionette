// Marionette.View
// ---------------

// The core view type that other Marionette views extend from.
Marionette.View = Backbone.View.extend({

  constructor: function(){
    var eventBinder = new Marionette.EventBinder();
    _.extend(this, eventBinder);

    Backbone.View.prototype.constructor.apply(this, arguments);

    this.bindBackboneEntityTo(this.model, this.modelEvents);
    this.bindBackboneEntityTo(this.collection, this.collectionEvents);

    this.bindTo(this, "show", this.onShowCalled, this);
  },

  // Get the template for this view
  // instance. You can set a `template` attribute in the view
  // definition or pass a `template: "whatever"` parameter in
  // to the constructor options.
  getTemplate: function(){
    var template;

    // Get the template from `this.options.template` or
    // `this.template`. The `options` takes precedence.
    if (this.options && this.options.template){
      template = this.options.template;
    } else {
      template = this.template;
    }

    return template;
  },

  // Mix in template helper methods. Looks for a
  // `templateHelpers` attribute, which can either be an
  // object literal, or a function that returns an object
  // literal. All methods and attributes from this object
  // are copies to the object passed in.
  mixinTemplateHelpers: function(target){
    target = target || {};
    var templateHelpers = this.templateHelpers;
    if (_.isFunction(templateHelpers)){
      templateHelpers = templateHelpers.call(this);
    }
    return _.extend(target, templateHelpers);
  },

  // Configure `triggers` to forward DOM events to view
  // events. `triggers: {"click .foo": "do:foo"}`
  configureTriggers: function(){
    if (!this.triggers) { return; }

    var triggers = this.triggers;
    var that = this;
    var triggerEvents = {};

    // Allow `triggers` to be configured as a function
    if (_.isFunction(triggers)){ triggers = triggers.call(this); }

    // Configure the triggers, prevent default
    // action and stop propagation of DOM events
    _.each(triggers, function(value, key){

      triggerEvents[key] = function(e){
        if (e && e.preventDefault){ e.preventDefault(); }
        if (e && e.stopPropagation){ e.stopPropagation(); }
        that.trigger(value);
      };

    });

    return triggerEvents;
  },

  // Overriding Backbone.View's delegateEvents specifically
  // to handle the `triggers` configuration
  delegateEvents: function(events){
    events = events || this.events;
    if (_.isFunction(events)){ events = events.call(this); }

    var combinedEvents = {};
    var triggers = this.configureTriggers();
    _.extend(combinedEvents, events, triggers);

    Backbone.View.prototype.delegateEvents.call(this, combinedEvents);
  },

  // Internal method, handles the `show` event.
  onShowCalled: function(){},

  // Default `close` implementation, for removing a view from the
  // DOM and unbinding it. Regions will call this method
  // for you. You can specify an `onClose` method in your view to
  // add custom code that is called after the view is closed.
  //
  // When overriding in sub-types, the `cb` parameter is a callback
  // that receives the `close` inner method. The `View.prototype.close`
  // method should be called like this:
  //
  // ```js
  // close: function(){
  //   Backbone.Marionette.View.prototype.close.call(this, function(close){
  //     // pre-close code goes here
  //     close(); // close the view
  //     // post-close code goes here
  //   });
  // }
  // ```
  close: function(cb){
    if (this.isClosed) { return; }

    var close = _.bind(function(){
      if (this.beforeClose) { this.beforeClose(); }
      this.remove();
      if (this.onClose) { this.onClose(); }
      this.trigger('close');
      this.unbindAll();
    }, this);

    if (_.isFunction(cb)){
      cb.call(this, close);
    } else {
      close();
    }

    this.isClosed = true;
  },

  // This method binds the elements specified in the "ui" hash inside the view's code with
  // the associated jQuery selectors.
  bindUIElements: function(){
    if (!this.ui) { return; }

    var that = this;

    if (!this.uiBindings) {
      // We want to store the ui hash in uiBindings, since afterwards the values in the ui hash
      // will be overridden with jQuery selectors.
      this.uiBindings = this.ui;
    }

    // refreshing the associated selectors since they should point to the newly rendered elements.
    this.ui = {};
    _.each(_.keys(this.uiBindings), function(key) {
      var selector = that.uiBindings[key];
      that.ui[key] = that.$(selector);
    });
  },

  // This method is used to bind a backbone "entity" (collection/model) to methods on the view.
  bindBackboneEntityTo: function(entity, bindings){
    if (!entity || !bindings) { return; }

    var view = this;
    _.each(bindings, function(methodName, evt){

      var method = view[methodName];
      if(!method) {
        throw new Error("View method '"+ methodName +"' was configured as an event handler, but does not exist.");
      }

      view.bindTo(entity, evt, method, view);
    });
  }
});
